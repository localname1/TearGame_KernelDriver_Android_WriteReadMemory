# 设置工具链路径
export CLANG_ROOT="/home/tear/toolchain/clang-r498229"
export CLANG_BIN="$CLANG_ROOT/bin"

# 验证工具链是否存在
ls -la $CLANG_BIN/clang
ls -la $CLANG_BIN/clang++
ls -la $CLANG_BIN/ld.lld


cd /home/tear/gki-kernel-6.6/common




# 设置架构
export ARCH=arm64
export SUBARCH=arm64

# 使用 LLVM 工具链
export LLVM=1
export LLVM_IAS=1

# 设置工具链路径（使用绝对路径）
export CC="$CLANG_BIN/clang"
export CXX="$CLANG_BIN/clang++"
export LD="$CLANG_BIN/ld.lld"
export AR="$CLANG_BIN/llvm-ar"
export NM="$CLANG_BIN/llvm-nm"
export STRIP="$CLANG_BIN/llvm-strip"
export OBJCOPY="$CLANG_BIN/llvm-objcopy"
export OBJDUMP="$CLANG_BIN/llvm-objdump"
export READELF="$CLANG_BIN/llvm-readelf"

# 主机工具链（用于编译 host 程序）
export HOSTCC="$CLANG_BIN/clang"
export HOSTCXX="$CLANG_BIN/clang++"
export HOSTLD="$CLANG_BIN/ld.lld"
export HOSTAR="$CLANG_BIN/llvm-ar"



# 使用 GKI 默认配置
make ARCH=arm64 LLVM=1 \
    CC="$CLANG_BIN/clang" \
    LD="$CLANG_BIN/ld.lld" \
    AR="$CLANG_BIN/llvm-ar" \
    NM="$CLANG_BIN/llvm-nm" \
    STRIP="$CLANG_BIN/llvm-strip" \
    OBJCOPY="$CLANG_BIN/llvm-objcopy" \
    OBJDUMP="$CLANG_BIN/llvm-objdump" \
    READELF="$CLANG_BIN/llvm-readelf" \
    HOSTCC="$CLANG_BIN/clang" \
    HOSTCXX="$CLANG_BIN/clang++" \
    HOSTLD="$CLANG_BIN/ld.lld" \
    HOSTAR="$CLANG_BIN/llvm-ar" \
    gki_defconfig




    # 获取 CPU 核心数（用于并行编译）
JOBS=$(nproc)

# 开始编译（使用多线程加速）
make ARCH=arm64 LLVM=1 LLVM_IAS=1 \
    CC="$CLANG_BIN/clang" \
    LD="$CLANG_BIN/ld.lld" \
    AR="$CLANG_BIN/llvm-ar" \
    NM="$CLANG_BIN/llvm-nm" \
    STRIP="$CLANG_BIN/llvm-strip" \
    OBJCOPY="$CLANG_BIN/llvm-objcopy" \
    OBJDUMP="$CLANG_BIN/llvm-objdump" \
    READELF="$CLANG_BIN/llvm-readelf" \
    HOSTCC="$CLANG_BIN/clang" \
    HOSTCXX="$CLANG_BIN/clang++" \
    HOSTLD="$CLANG_BIN/ld.lld" \
    HOSTAR="$CLANG_BIN/llvm-ar" \
    -j$JOBS


第三步：编译内核模块

# 进入模块目录
cd /home/tear/gki-kernel-6.6/HELLO66module
# 编译模块
make
# 或者指定内核源码路径（如果需要）
make KDIR=/home/tear/gki-kernel-6.6/common